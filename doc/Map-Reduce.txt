例：函数 f(x0,x1,x2)
x0，x1，x2 为不同类型，并有不同的完整性要求
x0：NONE
x1：MAP
x2：REDUCE

一、输入数据类型的完整flag定义
NONE：完全无法并行，f 必须在获取到完整的x0之后运算。
MAP：完全可并行，f(x1) = f(MERGE(SPLIT(x1))) = MERGE(f(SPLIT(x1)))
REDUCE：归约式并行，f(x2) = f(MERGE(SPLIT(x2))) = f(MERGE(f(SPLIT(x2))))

二、框架设计
1、规定新的类型：
class IDataSplitter
{
    public:
        virtual uint64_t vGetSplitNumber() = 0;
        virtual GPContent::Unit vExtract(uint64_t id) = 0;
};
class IDataCollector
{
    public:
        virtual GPContent::Unit vOutput() = 0;

        /*output 和number 至少有一个须不为空，可以先让output为空获取数量，申请好内存后再调一次*/
        virtual void vGetCurrentKeys(uint64_t* output, int* number) const = 0;

        /*考虑到可能有多个 Collector 合并，因此key可能有多个*/
        virtual void vCollect(uint64_t* key, int keyNumber, GPContent::Unit value) = 0;
};

2、数据类型接口（IStatusType的虚函数）
（1）IDataSplitter* vGetList(void*) ：获取一个数据分裂器
（2）IDataCollector* vCreateCollector(uint64_t* keyNumber, int keyGroup) ：创建一个数据聚集器

MAP(f(g(x0), h(x1), x2), x0);

REDUCE(f(x0), x0);
COLLECT();


